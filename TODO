______________________
The Soothsayer project
~~~~~~~~~~~~~~~~~~~~~~

TODO list
---------


Absolute first
 - fix distcheck (problem with abbreviations file retrieval)
 - document soothsayer interface (soothsayer.h)
 - remove duplicate code (pluginsTestMockObjects) in plugins tests
 - prevent .svn directory from being included in tarball (src/tinyxml)
 - make soothsayerSimulator accept normal text files, as opposed to
   files containing one token per line
 - pluginManagerDriver, pluginManager are currently not necessary, as
   dynamic plugin loading is disabled. This functionality will
   eventually be reinstated and supplied by the plump project.
   files:
      src/core/pluginManager.h
      src/core/pluginManager.cpp
      test/core/pluginManagerDriver.cpp
   should be taken care of as part of plump integration

Architectural restructure: 
- profile
  lifetime of Profile object is tied to TiXmlDocument object in
   ProfileManager, but relationship is not enforced by classes'
   implementation, i.e. it might be that other objects are using a
   Profile object that points to a no longer existing TiXmlDocument. A
   possible solution would be to have Profile cache the configuration
   into a map of < vector<string>, string > pairs.

- predictive plugins
  could inherit from a Predictor class
  Plugin class should just define the interface, PluginBase should
  provide a skeleton implementation class that concrete plugins would
  inherit from.

- selector
  should be a class similar to current Predictor i.e. a class that
  invokes other classes' method to perfom work.
  Current Selector's functionality should be broken up in Filter
  objects i.e. an abstract Filter class and implementation of variuos
  filters (repetion filter, greedy filter, etc)

- combiner
  clean up the mess that is our current Predictor implementation,
   particularly with regards to the Combiner handling and
   implementation. Considering making Combiner a concrete class that
   uses different CombinationStrategy objects to do combine
   predictions. Combiner object would know how to retrieve its config
   values and which Strategy to create and use.


Tests in general should be cleaned up (e.g. we don't need the xDriver
   anymore, those tests should be moved to CPPUnit tests)
 - drivers in src/plugins
 - pluginManagerDriver in test/core

SoothsayerDemo program:
 - add command line option to set number of suggestions

Configuration mechanism, from XML DOM to config classes that are
   visited by a ConfiguratorVisitor


Short term:
* implement abbreviation expansion plugin
* rename HistoryTracker to ContextTracker
* add ContextTracker tests for control chars
* put everything inside the soothsayer namespace
* write Combiner implementations (various combination strategies)
* restructure directories regarding config files and plugins etc.
* port existing tests to cppunit test cases
* add more tests to increase coverage
* bug: validate string passed to sql_exec query function, unsanitized
   string can cause security problems

- investigate the effectiveness of sourcing the initial prefix
   completion list from a different table. One possible idea is to use
   the table that has the strongest weight.
- try to improve reverseTokenizer::progress() accuracy
   currently it uses a delta of 0.7, should try to get it down to 0.3
- Class HistoryTracker could initialize Tokenizer's members separator
   and blankspace on a member initializer list. Also, Tokenizer could
   take references to string instead of pointers.
- add simulator tests - i.e. given a carefully crafted input text and
  a purpose developed plugin and related resources, test that it
  returns the correct simulation and keystroke reduction rates
- add custom profile loading support and add more tests to
   profileManager, use config file in user directory

Medium term:
* fix character codes
* overhaul of soothsayer architecture and integration of the plump framework

Long term:
* use timer alarm to implement threaded plugins controller
* improve exceptions handling
* add more predictive plugins

Longer term:
* add gettext support
* add UNICODE support




Plugins and Profiles and Managers
---------------------------------

A problem arises when a profile requires that more than one instance
of a Plugin object is created.

profile: pluginA, pluginB, pluginA

plugins: pluginA, pluginB, pluginA

libraries: libpluginA, libpluginB

We need to be able to distinguish (therefore separately manage) plugin
objects and library objects and profile objects.

libpluginA --->	pluginA
            |
libpluginB -+->	pluginB
            |
	    `->	pluginA

ProfileManager should invoke the construction of Plugin objects and
initiate their option values using a PluginFactory class.

PluginManager should manager the association between a Plugin object
and the module (library) object that contains the Plugin.

Plump, the Pluggable Lightweight Multithreaded Platform, was created
to solve this and other problems and is going to become soothsayer's
plugin framework implementation.


Plump framework integration
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The dynamic loading and plugin management system currently implemented
   is going to be scrapped in favour of the more general and portable
   plump framework.

   Plump is a Pluggable Lightweight Ubiquitous Multithreaded Platform
   which makes integration, usage and deployment of a plugin framework
   dead easy.

   Plump integration into soothsayer will require a number of changes to
   soothsayer architecture, affecting Predictor and PluginManager
   classes in particular.

   Predictor and PluginManager classes will delegate much of their
   current functionality to plump. Plump will render the functionality
   provided by PluginManager redundant, as everything that
   PluginManager does will be done by plump. Similarly, part of the
   Predictor class functionality will be replaced by plump too.

   Predictor was intended to be used to execute the plugins in a
   serial or parallel mode. Plump will do that. Predictor will still
   be in charge of collecting the result of each plugin's run and
   combining them into a global prediction.

   PluginManager was in fact a lesser plump. PluginManager can be
   considered a precursor to plump. Plump has been designed to solve
   the same problems that PluginManager was intended to solve, plus a
   bit more.


Plugins creation and initialisation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A few things should happen:
   plugin objects should be instantiated based on configuration files,
   that is if the configuration file uses the plugin, then an instance
   of the corresponding class implementing the plugin should be
   instantiated

   plugin objects should be initialised with the options contained in
   the configuration file

The most sensible way to achieve this requirements seems to revolve
around having a plugin factory class which:

   determines which and how many instances of plugin classes need to
   be instantiated from the xml configuration file

   passes a pointer to the root the xml representation of the options
   specific to that plugin so that the plugin constructor can
   initialise its internal state accordingly

This results in:

   plugins know how to initialise themselves
   the information required for initizialisation is passed to the
   plugin's constructor
   the information is passed in xml parse tree format


Points to ponder:
(o) the plugin factory needs to be able to determine which plugin
   class to instantiate a plugin from based on the content of the
   configuration file (xml file). A solution could be that the module
   implementing the plugin class exports a string corresponding to the
   plugin type/name.
(o) it is necessary to be able to associate a plugin object with
   initialisation data. In other words, each plugin class needs to
   have an associated string that describes its kind. Or we can use
   run-time type information.
(o) in light of all this, it is probably worth designing a versioning
   system for plugin classes to be implemented as exported symbols in
   the plugin module.




STEP to autoconfiscate
~~~~~~~~~~~~~~~~~~~~~~

aclocal
libtoolize --force --ltdl
autoheader
autoconf
automake -a --copy

or source the bootstrap script provided (in svn repo):
. bootstrap


----
DONE
~~~~

- configuration pulling instead of pushing
  instead of having a smart ProfileManager actively initializing each
  component (including plugins), the individual components should
  pull the config variable they require from ProfileManager.  This
  means that the plugins must have a handle to the ProfileManager and
  call a query method passing what config variable they want and
  returning a string with the value. The plugin will then convert the
  string to the appropriate type and use it internally. The advantage
  of this approach is that the plugin will know what variables it
  wants and their type (can throw an exception if unable to convert
  value to appropriate type); ProfileManager does not need to be
  smart, and there is no need of a PluginManager to keep track of
  active plugins, since plugins will pull the config variables they
  need.
   + profileManager: add ~/.soothsayer/soothsayer.xml searching

